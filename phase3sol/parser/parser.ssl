%  PT Parser Version 5.0
%
% Date:  30 Jun 1980
%        (Revised v5.0 - 10 Dec 2020)
%        (Revised for Like - JC 31 Dec 2020 - Changes marked %%)
%
% Author:  Alan Rosselet
%
% Abstract
%     This module parses the syntax token stream emitted by the scanner
%     and emits a postfix stream of tokens to the semantic analyzer
%     module.  The parser detects and repairs syntax errors so that the
%     token stream emitted to the semantic analyzer is syntactically
%     legal (except for the special case of declaration phase errors - 
%     see the comment in the Block routine below).

Input :
        % Keywords must be first both here and in stdIdentifiers,
        % and they must appear in the exact same order

%% CHANGED
%%      pDiv                    'div'
%%      firstKeywordToken = pDiv
%%      pMod                    'mod'
%%      pOr                     'or'
%%      pAnd                    'and'
%%      pNot                    'not'
%%      pThen                   'then'
%%      pElse                   'else'
%%      pOf                     'of'
%%      pEnd                    'end'
%%      pUntil                  'until'
%%      pDo                     'do'
%%      pArray                  'array'
%%      pFile                   'file'
%%      pProgram                'program'
%%      pConst                  'const'
%%      pVar                    'var'
%%      pType                   'type'
%%      pProcedure              'procedure'
%%      pBegin                  'begin'
%%      pIf                     'if'
%%      pCase                   'case'
%%      pWhile                  'while'
%%      pRepeat                 'repeat'
%%      lastKeywordToken = pRepeat 
%% TO
        pUsing                  'using'
        firstKeywordToken = pUsing
        pPublic                 'public'
        pVal                    'val'
        pVar                    'var'
        pFile                   'file'
        pLike                   'like'
        pFun                    'fun'
        pIs                     'is'
        pPkg                    'pkg'
        pIf                     'if'
        pThen                   'then'
        pElseif                 'elseif'
        pElse                   'else'
        pEnd                    'end'
        pRepeat                 'repeat'
        pWhile                  'while'
        pChoose                 'choose'
        pOf                     'of'
        pWhen                   'when'
        pAnd                    'and'
        pOr                     'or'
        pNot                    'not'
        lastKeywordToken = pNot
%% END

        % Scanner tokens -
        %   These are the tokens actually recognized by the Scanner itself.

        % Compound tokens - 
        %   These will be sent to the parser with a value or index.
        pIdentifier 
        firstCompoundInputToken = pIdentifier
        pInteger
        pStringLiteral
        lastCompoundInputToken = pStringLiteral

        % Non-compound tokens - 
        %   These tokens simply represent themselves.
        pNewLine
        pEndFile
        pPlus                   '+'
        pMinus                  '-'
        pStar                   '*'
%% DELETED
%%      pColonEquals            ':='
%% END
        pDot                    '.'
        pComma                  ','
        pSemicolon              ';'
        pColon                  ':'
        pEquals                 '='
%% ADDED
        pPlusEquals             '+='
        pMinusEquals            '-='
        pStarEquals             '*='
        pSlashEquals            '/='
        pPercentEquals          '%='
        pDoubleEquals           '=='
%% END
%% CHANGED
%%      pNotEqual               '<>'
%% TO
        pNotEqual               '!='
%% END
        pLess                   '<'
        pLessEqual              '<='
        pGreaterEqual           '>='
        pGreater                '>'
        pLeftParen              '('
        pRightParen             ')'
        pLeftBracket            '['
        pRightBracket           ']'
%% ADDED
        pSlash                  '/'
        pPercent                '%'
        pHash                   '#'
        pOrBar                  '|'
        pDoubleOrBar            '||'
%% END
        pDotDot                 '..'
        lastSyntaxToken = pDotDot;

Output :
        sIdentifier 
        firstSemanticToken = sIdentifier
        firstCompoundSemanticToken = sIdentifier
        sInteger
        sStringLiteral
        lastCompoundSemanticToken = sStringLiteral

        sProgram
        sParmBegin
        sParmEnd
        sConst
%% DELETED
%%      sType
%% END
        sVar
%% ADDED
        sPublic
        sLike
        sInitialValue
        sPackage
%% END
        sProcedure
        sBegin
        sEnd
        sNegate
        sArray
        sFile
        sRange
        sCaseStmt
%% ADDED
	sCaseElse
%% END
        sCaseEnd
        sLabelEnd
        sExpnEnd
        sNullStmt
        sAssignmentStmt
        sSubscript
        sCallStmt
        sFieldWidth
        sIfStmt
        sThen
        sElse
        sWhileStmt
        sRepeatStmt
        sRepeatEnd
        sEq
        sNE
        sLT
        sLE
        sGT
        sGE
        sAdd
        sSubtract
        sMultiply
        sDivide
        sModulus
        sInfixOr
        sOr
        sInfixAnd
        sAnd
        sNot
%% ADDED
        sConcatenate
        sRepeatString
        sSubstring
        sLength
%% END
        sNewLine
        sEndOfFile
        lastSemanticToken = sEndOfFile;


rules

Program :
%% CHANGED
%%      'program'  .sProgram
%%      % program name
%%      pIdentifier
%% TO
        'using'  .sProgram
        % no program name
%% END
        % program parameters
%% DELETED
%%      '('
%% END
        {
            pIdentifier  .sIdentifier
            [
                | ',':
                | *:
                    >
            ]
        }
%% DELETED
%%      ')'
%% END
        .sParmEnd
%% CHANGED
%%      ';'  @Block  '.';
%% TO
        ';'  @Block ;
%% END

Block :
        % Strictly speaking, standard Pascal requires that declarations
        % appear only in the order consts, types, vars, procedures.
        % We allow arbitrary intermixing of these instead to preserve
        % programmer sanity.
%% ADDED
        .sBegin
%% END
        {[
%% CHANGED
%%          | 'const':
%% TO
            | 'val':
%% END
                .sConst
                @ConstantDefinitions
%% DELETED
%%          | 'type':
%%              .sType
%%              @TypeDefinitions
%% END
            | 'var':
                .sVar
                @VariableDeclarations
%% CHANGED
%%          | 'procedure':
%% TO 
            | 'fun':
%% END
                .sProcedure
                % procedure name
                pIdentifier  .sIdentifier
                @ProcedureHeading
%% CHANGED
%%              @Block  ';'
%% TO 
                'is' 
                @Block  
                'end' ';'
%% END
%% ADDED
            | 'public':
                [
                    | 'val':
                        .sConst 
                        @PublicConstantDefinitions
                    | 'var':
                        .sVar 
                        @PublicVariableDeclarations
                    | 'fun':
                        .sProcedure 
                        % procedure name
                        pIdentifier  .sIdentifier
                        .sPublic
                        @ProcedureHeading
                        'is' 
                        @Block  
                        'end' ';'
                ]
            | 'pkg':
                .sPackage
                pIdentifier .sIdentifier
                'is' 
                @Block  
                'end' ';'
%% END
%% ADDED
            | pIdentifier:
                @AssignmentOrCallStmt
            | 'if':
                @IfStmt
            | 'repeat':
                [
                    | 'while':
                        @WhileStmt
                    | *:
                        @RepeatStmt
                ]
            | 'choose':
                @CaseStmt
            | ';':
                .sNullStmt
%% END
            | *:
                >
        ]}
%% CHANGED
%%      'begin'
%%      @BeginStmt;
%% TO 
        .sEnd;
%% END

ConstantDefinitions :
        % Accept one or more named constant definitions
        pIdentifier  .sIdentifier
%% CHANGED
%%      '=' @ConstantValue ';'
%%      {[
%%          | pIdentifier:
%%              .sIdentifier
%%              '=' @ConstantValue ';'
%%          | *:
%%              >
%%      ]};
%% TO 
        '=' @ConstantValue
        {[
            | ',':
                pIdentifier
                .sIdentifier
                '=' @ConstantValue
            | *:
                >
        ]}
        ';';
%% END

%% ADDED
PublicConstantDefinitions :
        % Accept one or more named constant definitions
        pIdentifier  .sIdentifier
        .sPublic
        '=' @ConstantValue
        {[
            | ',':
                pIdentifier
                .sIdentifier
                .sPublic
                '=' @ConstantValue
            | *:
                >
        ]}
        ';';
%% END

ConstantValue :
        [
            | pInteger:
                .sInteger
            | pIdentifier:
                .sIdentifier
            | '-':
                @UnsignedIntegerConstant
                .sNegate
            | '+':
                @UnsignedIntegerConstant
            | pStringLiteral:
                .sStringLiteral
        ];

UnsignedIntegerConstant :
        [
            | pIdentifier:
                .sIdentifier
            | pInteger:
                .sInteger
        ];

%% DELETED
%% TypeDefinitions :
%%      % Accept one or more named type definitions.
%%      pIdentifier  .sIdentifier
%%      '='  @TypeBody  ';'
%%      {[
%%          | pIdentifier:
%%              .sIdentifier
%%              '='  @TypeBody  ';'
%%          | *:
%%              >
%%      ]};
%% 
%% TypeBody :
%%      [
%%          | 'array':
%%              .sArray
%%              '['  @SimpleType  ']'
%%              'of'  @SimpleType
%%          | 'file':
%%              .sFile
%%              'of'  @SimpleType
%%          | *:
%%              @SimpleType
%%      ];
%% 
%% SimpleType :
%%      % A simple type is a named type (possibly predefined)
%%      % or a subrange type specification
%%      [
%%          | pIdentifier:
%%              .sIdentifier
%%              [
%%                  | '..':
%%                      .sRange         %% this may be unnecessary
%%                      @OptionallySignedIntegerConstant
%%                  | *:
%%              ]
%%          | *:
%%              @OptionallySignedIntegerConstant
%%              '..'  .sRange
%%              @OptionallySignedIntegerConstant
%%      ];
%% END

OptionallySignedIntegerConstant :
        [
            | '-':
                @UnsignedIntegerConstant
                .sNegate
            | '+':
                @UnsignedIntegerConstant
            | *:
                @UnsignedIntegerConstant
        ];

%% CHANGED
%% VariableDeclarations :
%%      % Accept one or more variable declarations.
%%      pIdentifier  .sIdentifier
%%      ':'  @TypeBody  ';'
%%      {[
%%          | pIdentifier:
%%              .sIdentifier
%%              ':'  @TypeBody  ';'
%%          | *:
%%              >
%%      ]};
%% TO
VariableDeclarations :
        % Accept one variable declaration
        pIdentifier  .sIdentifier
        @ValueOrLike
        ';';
%% END

%% ADDED
PublicVariableDeclarations :
        % Accept one variable declaration
        pIdentifier  .sIdentifier
        .sPublic
        @ValueOrLike
        ';';
%% END

%% ADDED
ValueOrLike :
        [
            | '=':
                .sInitialValue
                @Expression
                .sExpnEnd
            | *:
                @LikeClause
        ];

LikeClause :
        [
            | '[':
                .sArray
                @ConstantValue
                ']'
            | *:
        ]
        ':' 
        [
            | 'file':
                .sFile
            | *:
        ]
        'like' .sLike
        @VariableOrConstant;

VariableOrConstant :
        [
            | pIdentifier:
                .sIdentifier
            | *:
                @ConstantValue
        ];
%% END

ProcedureHeading :
        % Accept zero or more procedure formal parameter declarations.
        [
            | '(':
                {
                    % formal parameter identifier
                    [
                        | 'var':
                            pIdentifier  .sIdentifier
                            .sVar
                        | *:
                            pIdentifier  .sIdentifier
                    ]
%% CHANGED
%%                  ':'
%%                  % type identifier
%%                  pIdentifier  .sIdentifier
%% TO 
                    @LikeClause
%% END
                    [
%% CHANGED
%%                      | ';':
%% TO 
                        | ',':
%% END
                        | *:
                            >
                    ]
                }
                ')'
            | *:
        ]
%% DELETED
%%      ';'
%% END
        .sParmEnd;

%% CHANGED
%% Statement :
%%      [
%%          | pIdentifier:
%%              @AssignmentOrCallStmt
%%          | 'begin':
%%              @BeginStmt
%%          | 'if':
%%              @IfStmt
%%          | 'while':
%%              @WhileStmt
%%          | 'case':
%%              @CaseStmt
%%          | 'repeat':
%%              @RepeatStmt
%%          | *:
%%              .sNullStmt
%%      ];
%% TO 
Statement :
        @Block;
%% END

AssignmentOrCallStmt :
        [
%% CHANGED
%%          | ':=':
%%              .sAssignmentStmt
%%              .sIdentifier    % identifier accepted in the Statement rule
%%              @Expression
%%              .sExpnEnd
%% TO 
            | '=':
                .sAssignmentStmt
                .sIdentifier    % identifier accepted in the Statement rule
                @Expression
                .sExpnEnd
            | '+=':
                .sAssignmentStmt
                .sIdentifier    % identifier accepted in the Statement rule
                .sIdentifier    
                @Expression
                .sAdd
                .sExpnEnd
            | '-=':
                .sAssignmentStmt
                .sIdentifier    % identifier accepted in the Statement rule
                .sIdentifier    
                @Expression
                .sSubtract
                .sExpnEnd
            | '*=':
                .sAssignmentStmt
                .sIdentifier    % identifier accepted in the Statement rule
                .sIdentifier    
                @Expression
                .sMultiply
                .sExpnEnd
            | '/=':
                .sAssignmentStmt
                .sIdentifier    % identifier accepted in the Statement rule
                .sIdentifier    
                @Expression
                .sDivide
                .sExpnEnd
            | '%=':
                .sAssignmentStmt
                .sIdentifier    % identifier accepted in the Statement rule
                .sIdentifier    
                @Expression
                .sModulus
                .sExpnEnd
%% END
            | '[':
                .sAssignmentStmt
                .sIdentifier
                .sSubscript
                @Expression
                .sExpnEnd
		']'
%% CHANGED
%%              ':='
%% TO 
                '='
%% END
                @Expression
                .sExpnEnd
            | *:
                @CallStmt
%% CHANGED
%%      ];
%% TO 
        ] ';';
%% END

CallStmt :
        .sCallStmt
        .sIdentifier    % procedure identifier accepted in the Statement rule
        % accept zero or more actual parameters
        [
            | '(':
                {
                    @Expression
                    .sExpnEnd
                    % allow a field width specification to occur in calls
                    % to the standard procedures write and writeln
                    [
                        | ':':
                            .sFieldWidth
                            @Expression
                            .sExpnEnd
                        | *:
                    ]
                    [
                        | ',':
                        | *:
                            >
                    ]
                }
                ')'
            | *:        % no actual parameters
        ]
        .sParmEnd;

%% DELETED
%% BeginStmt :
%%      .sBegin
%%      {
%%          @Statement
%%          [
%%              | ';':
%%              | 'end':
%%                  .sEnd
%%                  >
%%          ]
%%      };
%% END

IfStmt :
        .sIfStmt
        @Expression
        .sExpnEnd
        'then'  .sThen
        @Statement
%% ADDED
        [
            | 'elseif':
                .sElse 
                .sBegin
                @IfStmt
                .sEnd
            | *:
%% END
		[
		    | 'else':
			.sElse
			@Statement
		    | *:
		]
%% ADDED
                'end' ';'
%% END
        ];

CaseStmt :
        .sCaseStmt
        @Expression
        .sExpnEnd
        'of'
%% ADDED
        'when'
%% END
        @CaseAlternative 
        {[
%% CHANGED
%%          | ';':
%%              % since case alternatives cannot be null, allow
%%              % for the common situation of an extra semicolon
%%              % at the end of the list of case alternatives.
%%              [
%%                  | 'end':
%%                      >
%%                  | *:
%%                      @CaseAlternative
%%              ]
%%          | 'end':
%% TO 
            | 'when':
                @CaseAlternative 
            | *:
%% END
                >
        ]}
        .sCaseEnd
%% ADDED
        [
            | 'else':
                .sCaseElse
                @Statement
            | *:
        ]
        'end' ';';
%% END

CaseAlternative :
        % A case alternative is a statement labelled by
        % one or more optionally signed integer constants

        {
            @OptionallySignedIntegerConstant
            [
                | ',':
                | *:
                    >
            ]
        }
        .sLabelEnd
%% CHANGED
%%      ':'  
%% TO 
        'then'  
%% END
        @Statement;

WhileStmt :
        .sWhileStmt
        @Expression
        .sExpnEnd
%% DELETED
%%      'do'
%% END
        @Statement
%% ADDED
        'end' ';';
%% END

RepeatStmt :
        .sRepeatStmt
        {
            @Statement
            [
%% CHANGED
%%              | ';':
%%              | 'until':
%% TO 
                | 'while':
%% END
                    .sRepeatEnd
                    >
            ]
        }
        @Expression 
%% ADDED
	';'
        .sNot
%% END
        .sExpnEnd;

Expression :
        @SimpleExpression
        [
%% CHANGED
%%          | '=':
%%              @SimpleExpression  .sEq
%%          | '<>':
%%              @SimpleExpression  .sNE
%% TO 
            | '==':
                @SimpleExpression  .sEq
            | '!=':
                @SimpleExpression  .sNE
%% END
            | '<':
                @SimpleExpression  .sLT
            | '<=':
                @SimpleExpression  .sLE
            | '>':
                @SimpleExpression  .sGT
            | '>=':
                @SimpleExpression  .sGE
            | *:
        ];

SimpleExpression :
        [
            | '+':
                @Term
            | '-':
                @Term  .sNegate
            | *:
                @Term
        ]
        {[
            | '+':
                @Term  .sAdd
            | '-':
                @Term  .sSubtract
            | 'or':
                .sInfixOr  @Term  .sOr
%% ADDED
            | '|':
                @Term  .sConcatenate
            | '||':
                @Term  .sRepeatString
%% END
            | *:
                >
        ]};

Term :
        @Factor
        {[
            | '*':
                @Factor  .sMultiply
%% CHANGED
%%          | 'div':
%%              @Factor  .sDivide
%%          | 'mod':
%%              @Factor  .sModulus
%% TO 
            | '/':
                @Factor  
                [
                    | ':':
                        @Factor .sSubstring
                    | *:
                        .sDivide
                ]
            | '%':
                @Factor  .sModulus
%% END
            | 'and':
                .sInfixAnd  @Factor  .sAnd
            | *:
                >
        ]};

Factor :
        [
            | pIdentifier:
                .sIdentifier
                @IdentifierExtension
            | pInteger:
                .sInteger
            | '(':
                @Expression  ')'
            | 'not':
                @Factor
                .sNot
%% ADDED
            | '#':
                @Factor
                .sLength
%% END
            | pStringLiteral:
                .sStringLiteral
            | 'file':
                .sFile '(' @Expression ')'
                .sExpnEnd
        ];

IdentifierExtension :
        % Handle subscripts and function actual parameter lists
        [
            | '[':
                .sSubscript
                @Expression  ']'
                .sExpnEnd
            | '(':
                .sParmBegin
                @Expression  ')'
                .sExpnEnd
                .sParmEnd
            | *:
        ];

end
